```
title: "Отладчик"
```

В Flixel есть довольно мощный отладчик. Открыть его можно, нажав любую из кнопок по умолчанию (`F2`, \` и \). Эти клавиши задаются через `FlxG.debugger.toggleKeys`. Также можно открыть его, поменяв значение у флага `FlxG.debugger.visible`;

Обратите внимание, что дебаггер отлючается при выставленном флаге компилятора `FLX_NO_DEBUG`. В конфигурационном файле проекта по умолчанию этот флаг включается в релизном билде.

![](../images/02_handbook/debugger/debugger-overlay.png)

## Отрисовка в отладчике

Можно включить `FlxG.debugger.drawDebug`, чтобы отображать хитбоксы всех `FlxObject`, добавленных в текущую сцену (либо нажать квадратную кнопку в верхнем правом углу отладчика).

![](../images/02_handbook/debugger/draw-debug.png)

Хитбоксы имеют разную расцветку в зависимости от характера столкновений. Для `FlxObject` и `FlxSprite`:

- Синий цвет для ситуации `allowCollisions == FlxObject.NONE`
- Зеленый - для неподвижных (`immovable`) объектов
- В противном случае - красный

Цвет можно задать через свойство `debugBoundingBoxColor`.

Цвета для тайлов в `FlxTilemap` означают немного другое:

- Синий цвет для ситуации `allowCollisions == FlxObject.NONE`
- Зеленый - для `allowCollisions == FlxObject.ANY`
- Розовый - для других значений свойства `allowCollisions`

## Окно логов

Окно логов используется для отображения сообщений и может быть доступно через `FlxG.log`. Также туда можно перенаправлять сообщения из вызова `trace()`, установив `FlxG.log.redirectTraces = true;`. Используйте этот метод по вашему усмотрению, т.к. многие предпочитают, чтобы сообщения выводились в среде разработки (например окне вывода во FlashDevelop).

Некоторые внутренние ошибки Flixel также выводятся в окно логов.

### Стили логов

У отображения окна логов есть возможность кастомизации, можно например поменять цвет текста, размер, стиль, либо добавить префикс, используя стили логов. `FlxG.log.warn()`, `error()` и `notice()` - преопределенные стили логов.

Ниже пример, как можно отличить сообщения игрока от других сообщений. Для этого добавляет префикс `[Player]` и меняется цвет на зеленый:

```haxe
var playerAction = new LogStyle("[Player]", "00FF40");
FlxG.log.advanced(" Shoot", playerAction);
```

## Окно наблюдения

Часто метод `trace()` используют чтобы выводить значение определенных переменных для отладки. Однако этот метод не совсем удобен, т.к. при 60 кадрах в секунду, вывод значения нескольких переменных влечет за собой трудночитаемый спам из сообщений. Отладка по брейкпоинтам - отличный способ отследить состояние игры, но не всегда подходит - например для отладки логики ввода, т.к. процесс выполения кода останавливается.

В этом случае поможет окно наблюдения. Оно отображает значения требуемых переменных. Например, если вы хотите отслеживать положение игрока:

```haxe
FlxG.watch.add(_player, "x");
FlxG.watch.add(_player, "y");
```

Отображаемое имя может быть изменено. Например, имя "numEnemies" намного понятнее, чем "length":

```haxe
FlxG.watch.add(_enemies, "length", "numEnemies");
```

![](../images/02_handbook/debugger/watch-window.png)

Для статичных переменных, вы можете передавать класс, вместо объекта:

```haxe
FlxG.watch.add(FlxG, "height");
```

Если кликнуть на переменную, можно поменять ее значение, введя новое значение и нажав Enter для подтверждения. Работает также с объектами `FlxPoint`.

Чтобы убрать переменную из окна, вызовите `FlxG.watch.remove(object, variableName)`.

### Быстрое наблюдение

Быстрое наблюдение - это более быстрый вариант обычного наблюдения. Оно не требует наличия переменной, а просто сохраняет значение для имени `String`. Пример ниже хранит результат выполнения функции `FlxG.keys.anyPressed(["UP", "W"])` под именем `"Up key pressed"` и обновляется каждый кадр, в котором выполнилось это условие.

```haxe
override public function update():Void
{
	super.update();
	FlxG.watch.addQuick("Up key pressed", FlxG.keys.anyPressed(["UP", "W"]));
}
```

Чтобы удалить запись из выстрого наблюдения, вызовите `FlxG.watch.removeQuick(name)`.

Значения из быстрого наблюдения не могут быть изменены вручную.

### Наблюдение за мышью

Метод `FlxG.watch.addMouse()` является удобным помощником для отображения текущей позиции мыши в окне наблюдения. Это можно использовать для поиска координат при позиционировании элементов интерфейса. Также для вызова этой функции можно использовать консольную команду `watchMouse`.

## Окно статистики

Окно статистики отображает некоторую основную информацию:

1. Текущий FPS
2. Использование памяти (в Мб)
3. Количество вызовов метода `update()` в текущем фрейме (и время на выполнение этой фукцнии в мс)
4. Количество вызовов метода `draw()` в текущем фрейме (и время на выполнение этой фукцнии в мс)
5. Размер объекта `FlxQuadtree` для определения столкновений
6. Размер объекта `FlxList` (используется для дерева квадрантов (quadtree))

Пункты 3 и 4 особенно полезны когда необходима оптимизация производительности (чтобы понять нужно ли оптимизировать рендер или логику). Конечно это очень базовая информация. Утилиты для профилирования, такие как [Adobe Scout](https://creative.adobe.com/products/scout) или [hxScout](http://hxscout.com) предоставляют намного больше информации.

![](../images/02_handbook/debugger/stats-window.png)

## Окно логов Bitmap

Окно логов Bitmap может быть использовано чтобы отображать объекты `BitmapData` с помощью вызова метода `FlxG.bitmapLog.add(bitmapData)`. Может быть полезно для отладки логики с использованием `BitmapData`. Окно предоставляет слайдер для прокрутки логируемых изображений. Вы можете использовать среднюю кнопку мыши, чтобы перемещать картинки и колесико мыши для увеличения и уменьшения масштаба.

Также вы можете следить за внутренним кешем `BitmapData`, вызвав метод `FlxG.bitmapLog.viewCache()` или введя команду `viewCache` в консоли.

![](../images/02_handbook/debugger/view-cache.png)

## Консоль

Консоль позволяет анализировать и выполнять ограниченное количество команд Haxe во время выполнения, с помощью [hscript](https://github.com/HaxeFoundation/hscript). Команды типа `state._player.x = 50` или `state._player.jump()` будут работать корректно. На таргетах с длительным временем компиляции, эти команды могут существенно сократить время разработки.

Также в консоли есть поддержка автокомплита для полей классов и зарегистрированных функции / объектов / классов, аналогично всплывающим окнам в среде разработки (хотя и без документации, которая недоступна во время выполнения).

![](../images/02_handbook/debugger/console-completion.png)

`state` это стартовая точка для `hscript` и должен быть зарегистрирован в консоли, чтобы быть доступным. Flixel делает это самостоятельно. Аналогично это выполняется для других классов, например `FlxG` или `Math`. Чтобы зарегистрировать дополнительные объекты или классы, вызовите `FlxG.console.registerObject()`.

По умолчанию игра ставится на паузу, когда текстовое поле консоли получает фокус. После выполнения команды, игра делает один кадр, чтобы можно было заметить эффект.

Консоль хранит выполненные команды (используйте стрелки вверх и вниз на клавиатуре, чтобы переключаться между ними). Эта история сохраняется в течении всех компиляций вашей игры (но не для разных целевых платформ).

### Добавление собственных команд

Функции также можно зарегистрировать в консоли, также как и команды через метод `FlxG.console.registerFunction()`. Ниже пример с функцией  `"spawnEnemy"`, которая создает нового противника в текущей позиции курсора мыши.

```haxe
// in PlayState#create()
FlxG.console.addCommand("spawnEnemy", function() {
	var mousePos = FlxG.mouse.getWorldPosition();
	var enemy = _enemies.recycle(Enemy);
	enemy.init(Std.int(mousePos.x), Std.int(mousePos.y), _enemyBullets, _bigGibs, _player);
});
```

## Трекеры

Трекеры - это удобный способ проверки наиболее важных свойств класса / объекта. Каждый трекер по сути является экземпляром окна наблюдения. Это единственное окно, которое можно закрыть.

_Профиль трекера_ определяет свойства, которые необходимо отслеживать для определенного класса. Ниже пример предопределенного профиля для трекера `FlxSprite`:

```haxe
new TrackerProfile(FlxSprite, ["frameWidth", "frameHeight", "alpha", "origin", "offset", "scale"], [FlxObject])
```

Первый параметр определяет класс, к которому профиль принадлежит. Второй - массив строк `Array<String>`, содержащий имена отображаемых свойств. Третий аргумент - список расширений - в данном случае просто `FlxObject`. Это означает, что свойства, определенные в профиле трекера `FlxObject`, будут добавлены в окна трекера для` FlxSprite`. Это работает рекурсивно - `FlxObject` "расширяет" профиль трекера `FlxBasic`, поэтому любые свойства этого профиля также будут добавлены к выводу. Вот почему `FlxG.debugger.track(_player)` в методе демо проекта `PlayState#create()` создает окно с более длинным списком свойств, чем вы ожидали от профиля` FlxSprite`:

![](../images/02_handbook/debugger/track-player.png)

Также можно использовать консоль, чтобы создавать трекеры во время выполнения программы:

`track(FlxG.state._player)`

Основным преимуществом трекеров является возможность определять собственные профили, например как для класса `Player`:

```haxe
FlxG.debugger.addTrackerProfile(new TrackerProfile(Player, ["isReadyToJump", "_shootCounter", "_jumpPower"], [FlxBasic]));
```

(Вызов `addTrackerProfile()` приводит к сбою в последней версии haxelib из-за ошибки. В качестве обходного пути вы можете до этого вызвать `FlxG.debugger.track(null);`).

![](../images/02_handbook/debugger/track-player-custom.png)

## VCR

VCR - функционал записи и воспроизведения (`FlxG.vcr`). Чаще всего отключен по умолчанию и может быть активирован с заданием флага `FLX_RECORD`. Тем не менее, некоторые функции по-прежнему доступны по умолчанию через средние три кнопки отладчика:

![](../images/02_handbook/debugger/vcr-disabled.png)

Левая кнопка перезапускает текущую сцену (state) путем вызова `FlxG.resetState()`.

Средняя кнопка ставит игру на паузу (и снимает с паузы).

Правая кнопка ставит игру на паузу (если она уже не на паузе) и выполняет ровно один кадр (один вызов `update()` и один вызов `draw()`). Это может быть очень полезно для отладки определенных проблем.

Если задан флаг `FLX_RECORD`, доступны еще 2 кнопки:

![](../images/02_handbook/debugger/vcr-enabled.png)

Круглая кнопка начинает новую запись (также она перезапускает сцену, т.к. VCR не поддерживает запись с середины состояния). Если запись уже запущена, кнопка останавливает ее и открывает диалоговое окно, чтобы сохранить запись в файл.

Кнопка со значком папки справа позволяет загружать файлы записей и воспроизводить их.

## Добавление кнопок в отладчик

Вы можете добавить собственные кнопки в верхнюю часть отладчика, используя `FlxG.debugger.addButton()`. Именно это и делает `FlxNapeState` из flixel-addons - добавляет удобную кнопку «N» для переключения отладки Nape.

![](../images/02_handbook/debugger/nape-button.png)

При смене сцены (state), кнопки отладчика не меняются. Используйте `FlxG.debugger.removeButton()` для удаления кнопок, заданных пользователем.

## Макеты отладчика

Макеты отладчика определяет позицию и размер каждого окна отладчика. Доступные макеты описаны в [FlxDebuggerLayout](http://api.haxeflixel.com/flixel/system/debug/FlxDebuggerLayout.html). Вы можете менять текущий макет вызовом функции `FlxG.debugger.setLayout()`.

Пример макета `FlxDebuggerLayout.RIGHT`:

![](../images/02_handbook/debugger/layout-right.png)

## Инструмент "Взаимодействие"

Инструмент "Взаимодействие" позволяет изменять элементы игры, например перемещать спрайты во время выполнения программы. Доступен при клике на иконку ![](../images/02_handbook/debugger/icons/interactive.png). [По ссылке](./debugger-interaction) доступно более подробное описание этого инструмента.
 
![](../images/02_handbook/debugger/interaction-mover-shortcut.gif)
